#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <arduinoFFT.h>

#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 32
#define OLED_RESET -1
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

#define MIC_PIN 34
#define SAMPLES 512
#define SAMPLING_FREQ 44100

double vReal[SAMPLES];
double vImag[SAMPLES];
ArduinoFFT<double> FFT = ArduinoFFT<double>(vReal, vImag, SAMPLES, SAMPLING_FREQ);

int RW = 61;
int RH = 15;
int boxX = (SCREEN_WIDTH - RW) / 2;
int boxY = (SCREEN_HEIGHT - RH) / 2;

String currentChord = "---";
int waveAmplitude = 3;
int waveLength = 16;
int waveSpeed = 2;
int phase = 0;

String detectedNotes[10];
int noteCount = 0;

int getFittingTextSize(const char* text, int boxW, int boxH) {
  int size = 1;
  while (size < 5) {
    int w = strlen(text) * 6 * (size + 1);
    int h = 8 * (size + 1);
    if (w > boxW || h > boxH) break;
    size++;
  }
  return size;
}

String freqToNote(double freq) {
  if (freq <= 0) return "";
  
  // Same as Python: semitones = 12 * log2(freq / 440.0)
  double semitones = 12.0 * log(freq / 440.0) / log(2.0);
  int semiIndex = (int)round(semitones);
  semiIndex = semiIndex % 12;
  if (semiIndex < 0) semiIndex += 12;
  
  String notes[] = {"A", "A#", "B", "C", "C#", "D", "D#", "E", "F", "F#", "G", "G#"};
  return notes[semiIndex];
}

String matchChord(String notes[], int count) {
  if (count == 1) return notes[0];
  if (count == 2) return "Too few";
  if (count < 1) return "---";
  
  // Check exact matches (your full chord database)
  bool hasC=false, hasE=false, hasG=false, hasDsharp=false;
  bool hasD=false, hasF=false, hasFsharp=false, hasA=false;
  bool hasGsharp=false, hasB=false, hasAsharp=false, hasCsharp=false;
  
  for (int i = 0; i < count; i++) {
    if (notes[i] == "C") hasC = true;
    if (notes[i] == "E") hasE = true;
    if (notes[i] == "G") hasG = true;
    if (notes[i] == "D#") hasDsharp = true;
    if (notes[i] == "D") hasD = true;
    if (notes[i] == "F") hasF = true;
    if (notes[i] == "F#") hasFsharp = true;
    if (notes[i] == "A") hasA = true;
    if (notes[i] == "G#") hasGsharp = true;
    if (notes[i] == "B") hasB = true;
    if (notes[i] == "A#") hasAsharp = true;
    if (notes[i] == "C#") hasCsharp = true;
  }
  
  // All 14 chords from your Python code
  if (hasC && hasE && hasG) return "C Major";
  if (hasC && hasDsharp && hasG) return "C Minor";
  if (hasD && hasFsharp && hasA) return "D Major";
  if (hasD && hasF && hasA) return "D Minor";
  if (hasE && hasGsharp && hasB) return "E Major";
  if (hasE && hasG && hasB) return "E Minor";
  if (hasF && hasA && hasC) return "F Major";
  if (hasF && hasGsharp && hasC) return "F Minor";
  if (hasG && hasB && hasD) return "G Major";
  if (hasG && hasAsharp && hasD) return "G Minor";
  if (hasA && hasCsharp && hasE) return "A Major";
  if (hasA && hasC && hasE) return "A Minor";
  if (hasB && hasDsharp && hasFsharp) return "B Major";
  if (hasB && hasD && hasFsharp) return "B Minor";
  
  return "Unknown";
}

void captureAndDetect() {
  // Sample at 44100 Hz (match Python RATE)
  unsigned long microsBetweenSamples = 1000000 / SAMPLING_FREQ;
  
  for (int i = 0; i < SAMPLES; i++) {
    unsigned long startMicros = micros();
    vReal[i] = analogRead(MIC_PIN);
    vImag[i] = 0;
    while (micros() - startMicros < microsBetweenSamples) {}
  }
  
  // FFT
  FFT.windowing(FFTWindow::Hamming, FFTDirection::Forward);
  FFT.compute(FFTDirection::Forward);
  FFT.complexToMagnitude();
  
  // Find peaks (match Python: threshold = 0.6 * max)
  noteCount = 0;
  double maxMag = 0;
  for (int i = 2; i < (SAMPLES / 2); i++) {
    if (vReal[i] > maxMag) maxMag = vReal[i];
  }
  
  double threshold = maxMag * 0.6;
  
  for (int i = 2; i < (SAMPLES / 2) && noteCount < 10; i++) {
    if (vReal[i] > threshold) {
      double freq = (i * 1.0 * SAMPLING_FREQ) / SAMPLES;
      
      // Filter frequencies > 80 Hz (match Python)
      if (freq > 80) {
        String note = freqToNote(freq);
        if (note != "") {
          // Check for duplicates
          bool dup = false;
          for (int j = 0; j < noteCount; j++) {
            if (detectedNotes[j] == note) dup = true;
          }
          if (!dup) {
            detectedNotes[noteCount++] = note;
            Serial.print(freq);
            Serial.print(" Hz -> ");
            Serial.println(note);
          }
        }
      }
    }
  }
  
  currentChord = matchChord(detectedNotes, noteCount);
  Serial.print("Chord: ");
  Serial.println(currentChord);
}

void drawDisplay() {
  display.clearDisplay();
  display.drawRect(boxX, boxY, RW, RH, WHITE);
  
  for (int i = 1; i <= 12; i++) {
    int ly = (i * SCREEN_HEIGHT) / 13;
    for (int x = 0; x < SCREEN_WIDTH; x++) {
      int y = ly;
      if (i >= 5 && i <= 8) {
        y += (int)(waveAmplitude * sin((x + phase) * 2 * PI / waveLength));
      }
      if (x < boxX || x > boxX + RW || y < boxY || y > boxY + RH) {
        if (!(i >= 5 && i <= 8) && (x % 5 == 0)) continue;
        display.drawPixel(x, y, WHITE);
      }
    }
  }
  
  int textSize = getFittingTextSize(currentChord.c_str(), RW - 4, RH - 4);
  display.setTextSize(textSize);
  display.setTextColor(WHITE);
  
  int w = currentChord.length() * 6 * textSize;
  int h = 8 * textSize;
  display.setCursor(boxX + (RW - w) / 2, boxY + (RH - h) / 2);
  display.print(currentChord);
  display.display();
  
  phase += waveSpeed;
}

void setup() {
  Serial.begin(115200);
  Wire.begin(21, 22);
  
  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
    for (;;);
  }
  
  display.clearDisplay();
  display.display();
  
  analogReadResolution(12);
  pinMode(MIC_PIN, INPUT);
  
  Serial.println("ChordMate Ready!");
}

void loop() {
  int loudness = 0;
  for (int i = 0; i < 100; i++) {
    loudness += abs(analogRead(MIC_PIN) - 2048);
  }
  
  // Match Python threshold logic (10000 for laptop mic, adjust for ESP32)
  if (loudness > 5000) {
    Serial.println("Sound detected!");
    captureAndDetect();
  }
  
  drawDisplay();
  delay(100);
}
